{"version":3,"sources":["webpack:///path---blog-what-is-ocaml-0446d0b1880d6f6620c3.js","webpack:///./.cache/json/blog-what-is-ocaml.json"],"names":["webpackJsonp","381","module","exports","data","markdownRemark","html","frontmatter","date","path","title","tags","pathContext"],"mappings":"AAAAA,cAAc,iBAERC,IACA,SAAUC,EAAQC,GCHxBD,EAAAC,SAAkBC,MAAQC,gBAAkBC,KAAA,67WAA+6VC,aAAoiBC,KAAA,iBAAAC,KAAA,sBAAAC,MAAA,sCAAAC,MAAA,eAAyHC","file":"path---blog-what-is-ocaml-0446d0b1880d6f6620c3.js","sourcesContent":["webpackJsonp([177863970890294],{\n\n/***/ 381:\n/***/ (function(module, exports) {\n\n\tmodule.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>In a world where there are hundreds of different programming languages to\\nchoose from, choosing the correct languages for a project or task can be\\noverwhelming and difficult. With this being said, there are certainly different\\nflavors of programming languages geared towards solving different types of\\nproblems. Among these, there is a family of general purpose functional\\nlanguages called MetaLanguage (or ML as it’s commonly referred to). Within the\\nfamily of MetaLanguage, there exists a uniquely interesting programming\\nlanguage called Objective Categorical Abstract Machine Language, which is\\ncommonly referred to as OCaml. OCaml was invented in 1996 by the Inria\\ncorporation. This language is primarily an extension of the Caml language\\nwith the inclusion of some object-oriented design. OCaml’s tool set and\\nfeatures are what make it a robust and powerful language to use in modern day\\napplications.</p>\\n<h2>Programming Paradigm</h2>\\n<p>OCaml is a general purpose functional programming language. By virtue of this,\\nthe language provides first class functions; this implies that functions are\\ntreated as proper variables. First class functions open the door to more\\npowerful methods of functional programming; OCaml is able to have higher order\\nfunctions, anonymous functions, and currying. Despite the functional paradigm\\nthat’s encouraged by the language itself, what makes this particular language\\nuseful is its support for both imperative styles of programming as well as\\nobject-oriented programming.</p>\\n<p>Imperative programming styles are, for the most part, fairly accounted for and\\nsupported in OCaml. This particular feature is useful because it ultimately\\ngives the developer greater control over the memory representation of data and\\nhow the program itself is executed. The language provides access to variables\\nand arrays; it can also record components which can be declared as mutable.\\nThis impure functional language might allow irresponsible developers to shoot\\nthemselves in the foot, but it also add more power to the language. The\\nimperative support allows OCaml program to have an extra layer of data control,\\nwhich consequently opens the door to more powerful abilities such as iteration\\nand rich data structures such as hashmaps.</p>\\n<p>The object-oriented features of OCaml allow developers to create objects and\\nclasses for their programs. Similarly to how the support for imperative\\nprogramming styles benefits OCaml, the object-oriented features allow for data\\norganization in classes and objects, and even goes as far as to provide more\\nrobust properties like polymorphic classes. Since OCaml’s object-oriented\\npattern allows for polymorphism, this gives developers the ability to create\\nmore complex programs and create abstract types.</p>\\n<p>Aside from the supported paradigms and styles of programming, OCaml, much like\\nall C and ML languages, is strict by default in the sense that it enforces\\neager evaluation. Many benefits can be derived from strict languages such as\\nOCaml; one major point being that there is no overhead for having to keep track\\nof evaluations much like there is in a non-strict or lazy language. OCaml has a\\nstrict evaluation pattern which implies that it has more control over when\\nexpressions are evaluated; this can help with catching bugs. Examples of this\\ncan be attempting to divide by zero in a function argument; with strict\\nevaluation, this argument gets evaluated first and the error is caught, whereas\\nwith a lazy evaluation, this error isn’t caught until the function itself is\\nexecuted.</p>\\n<h2>Type System</h2>\\n<p>Some of the more uniquely interesting and incredible aspects of OCaml include\\nits statically typed system, and its ability to leverage this to help produce\\nextremely performant code. The good thing about statically typed languages is\\nthat they help eliminate type conflicts at compile time rather than at runtime.\\nThis guarantee of safety ensures that programs are verified before they’re ever\\nexecuted. This feature is particularly helpful because it prevents very\\ncommon human errors that occur when developing a program: conflating an integer\\nand pointer, accessing an invalid piece of data, or buffer overflows, just to\\nname a few.</p>\\n<p>Performance is a rather large benefit we get from OCaml’s statically typed\\nsystem. Since any type conflicts are resolved at compile time, this eliminates\\nany need for type related safety checks at runtime. These kinds of checks are\\nnecessary for dynamically typed languages, which consequently add a slow\\noverhead, therefore slowing down the speed of the program itself. Most\\nscripting languages tend to be dynamically typed, so this simple change of\\ntype system puts OCaml far ahead of its peers with respect to speed. When it\\ncomes to benchmarking, OCaml is argued to be almost as fast as C, which is\\nincredibly impressive and unique considering it is a type safe language.</p>\\n<p>Not only is OCaml statically typed, but it also has type inference, which is\\nthe ability to automatically assume the data type of an expression at compile\\ntime, without its type needing to be explicitly defined. Rather, the compiler\\nwill generally either attempt to predict the type based on existing atomic data\\ntypes of the language, or it will try to gather information about the data\\nbeing analyzed, and come to a conclusion that way. As a matter of fact, entire\\nprograms can be written without explicitly declaring <em>any</em> types, and OCaml is\\nable to figure out all of the types automatically. Traditionally, this power\\ncomes at a cost; type inference is usually a relatively expensive feature to\\nsupport, and can be expected to ultimately slow down the compilation process.\\nIn OCaml, however, this isn’t the case due to its unique and revolutionary\\nimplementation of its type inference algorithm. OCaml has an interesting take\\non the usual approach; its own algorithm is a derivation of the common type\\ninference algorithm known as Algorithm W, only OCaml’s interpretation utilizes\\na graph based algorithm which ends up being a much more speed efficient\\nvariation of the traditional approach. The downside to the quick inference\\nimplementation, is that it can result in strange type errors in more\\ncomplicated programs.</p>\\n<h2>Modules and Functors</h2>\\n<p>Alongside these features, OCaml also comes with a mature module system that can\\nbe categorized into three key parts: signatures, structures, and functors. The\\nsignature of a module defines what type of data it can be parameterized with,\\nwhere the structure relates to how the body of the module is designed. Functors\\nare a very powerful feature in this module system; this is gives developers the\\nability to parameterize a module with <em>other</em> modules. This opens the door\\nto all sorts of complex programs; having modules that can be constructed using\\none or more other modules adds layers of abstraction that otherwise wouldn’t be\\nachievable in OCaml. A simple use case of functors could be the following:\\nlet’s say you have a module that creates a set of items, and in order to check\\nif an item already exists within a given set, we need to apply a custom\\nequality function. We can create an equality module and use it to parameterize\\nour set module so that we can apply our custom equality function within the set\\nmodule; this makes the set module a functor. Besides the support of functors,\\nthis module system can also be particularly helpful to developers for the\\nsimple added bonus of having namespacing within modules; this can help avoid\\nany naming conflicts that may occur in a program.</p>\\n<h2>Structure and Tool Set</h2>\\n<p>OCaml provides an extensive set of tools and libraries when it comes to\\ndevelopment, one of which being the interactive toplevel interpreter; this\\nsystem is designed in a read-eval-print loop where it repeatedly reads\\nexpressions from the input, type checks, compiles, evaluates, then prints the\\nresult. This is similar to how Racket’s interactive toplevel interpreter\\nworks (or Node.js, or most other interactive toplevel interpreters for that\\nmatter). Having this kind of tool makes the developer’s life very easy when\\nthey want to just test out some code quickly. The toplevel interpreter is also\\nused to interpret entire files of OCaml code; the general syntax is <code>ocaml options objects scriptfile</code>. Before a scriptfile is read by the interpreter,\\nOCaml will first search the current directory, and, if not found, then the\\n<code>HOME</code> directory for a <code>.ocamlinit</code> file. This file can be used to import\\nnecessary libraries that the program might need, or provide any other set up\\nrelated tasks.</p>\\n<p>OCaml also provides the developers with a bytecode compiler and a native code\\ncompiler. Similar to a C compiler, dependency ordering matters when trying to\\nlink and compile several files. This compiler will build and provide optimized\\nexecutable files that generally run faster than simply interpreting the source\\ncode, with the native code compiler usually being faster. The main purpose\\nof these compilers is for both portability and efficiency; OCaml is able to\\nbuild your files into very fast executables which, as we’ve mentioned earlier,\\nare roughly the same speed as C. There are some third party tools that\\nassist the developer in linking dependencies, one of the more popular ones\\nbeing <code>ocamake</code>; you feed it your source files and it will link them together\\nautomatically and the build them into an executable using the bytecode\\ncompiler. Tools like these alongside the compilers themselves really benefit\\nthe language in both efficiency and with being able to move code around on\\ndifferent systems.</p>\\n<p>Managing packages in OCaml is relatively easy due to the open source package\\nmanager called OPAM. This package manager supports multiple simultaneous\\ncompiler installations and also integrates well with a git based development\\nworkflows. OPAM is a way for engineers to easily install and share any open\\nsourced packages that they create and publish to the OPAM package registry,\\nwhich helps increase the speed of the development process by sharing commonly\\nused code. Especially for an emerging language like OCaml, the ability to\\nsimply distribute code and build a strong set of libraries really help the\\nlanguage grow and thrive as more developers begin to use it.</p>\\n<h2>In Closing</h2>\\n<p>OCaml is a powerful, general purpose functional programming language that has a\\nwide support for different needs. With its support of both imperative and\\nobject-oriented programming paradigms, it’s needless to say that this language\\nis very flexible when it comes to what the developer might need. With its\\nstatically typed system and very efficient implementation of its type inference\\nalgorithm, leveraging the native code compiler can result in OCaml programs\\nturning out to be almost as fast as C programs. With these strong\\ncharacteristics and features, it’s no wonder that OCaml is quickly growing in\\nthe open source software community; Facebook’s JavaScript static type checker,\\nFlow, is written in OCaml and proves to be one of the most revolutionary\\ntools a JavaScript developer can use. From using OCaml’s robust tool set and\\nspeedy execution, this software has quickly become one of the most popular\\nstatic type analyzers in the JavaScript community. All of OCaml’s features and\\nbenefits cause it to be an incredible language and tool to use in modern day\\napplications, and is slowly taking the world by storm as developers realize how\\npowerful it is.</p>\",\"frontmatter\":{\"date\":\"March 08, 2018\",\"path\":\"/blog/what-is-ocaml\",\"title\":\"What Is OCaml And Why Is It So Dope\",\"tags\":[\"language\"]}}},\"pathContext\":{}}\n\n/***/ })\n\n});\n\n\n// WEBPACK FOOTER //\n// path---blog-what-is-ocaml-0446d0b1880d6f6620c3.js","module.exports = {\"data\":{\"markdownRemark\":{\"html\":\"<p>In a world where there are hundreds of different programming languages to\\nchoose from, choosing the correct languages for a project or task can be\\noverwhelming and difficult. With this being said, there are certainly different\\nflavors of programming languages geared towards solving different types of\\nproblems. Among these, there is a family of general purpose functional\\nlanguages called MetaLanguage (or ML as it’s commonly referred to). Within the\\nfamily of MetaLanguage, there exists a uniquely interesting programming\\nlanguage called Objective Categorical Abstract Machine Language, which is\\ncommonly referred to as OCaml. OCaml was invented in 1996 by the Inria\\ncorporation. This language is primarily an extension of the Caml language\\nwith the inclusion of some object-oriented design. OCaml’s tool set and\\nfeatures are what make it a robust and powerful language to use in modern day\\napplications.</p>\\n<h2>Programming Paradigm</h2>\\n<p>OCaml is a general purpose functional programming language. By virtue of this,\\nthe language provides first class functions; this implies that functions are\\ntreated as proper variables. First class functions open the door to more\\npowerful methods of functional programming; OCaml is able to have higher order\\nfunctions, anonymous functions, and currying. Despite the functional paradigm\\nthat’s encouraged by the language itself, what makes this particular language\\nuseful is its support for both imperative styles of programming as well as\\nobject-oriented programming.</p>\\n<p>Imperative programming styles are, for the most part, fairly accounted for and\\nsupported in OCaml. This particular feature is useful because it ultimately\\ngives the developer greater control over the memory representation of data and\\nhow the program itself is executed. The language provides access to variables\\nand arrays; it can also record components which can be declared as mutable.\\nThis impure functional language might allow irresponsible developers to shoot\\nthemselves in the foot, but it also add more power to the language. The\\nimperative support allows OCaml program to have an extra layer of data control,\\nwhich consequently opens the door to more powerful abilities such as iteration\\nand rich data structures such as hashmaps.</p>\\n<p>The object-oriented features of OCaml allow developers to create objects and\\nclasses for their programs. Similarly to how the support for imperative\\nprogramming styles benefits OCaml, the object-oriented features allow for data\\norganization in classes and objects, and even goes as far as to provide more\\nrobust properties like polymorphic classes. Since OCaml’s object-oriented\\npattern allows for polymorphism, this gives developers the ability to create\\nmore complex programs and create abstract types.</p>\\n<p>Aside from the supported paradigms and styles of programming, OCaml, much like\\nall C and ML languages, is strict by default in the sense that it enforces\\neager evaluation. Many benefits can be derived from strict languages such as\\nOCaml; one major point being that there is no overhead for having to keep track\\nof evaluations much like there is in a non-strict or lazy language. OCaml has a\\nstrict evaluation pattern which implies that it has more control over when\\nexpressions are evaluated; this can help with catching bugs. Examples of this\\ncan be attempting to divide by zero in a function argument; with strict\\nevaluation, this argument gets evaluated first and the error is caught, whereas\\nwith a lazy evaluation, this error isn’t caught until the function itself is\\nexecuted.</p>\\n<h2>Type System</h2>\\n<p>Some of the more uniquely interesting and incredible aspects of OCaml include\\nits statically typed system, and its ability to leverage this to help produce\\nextremely performant code. The good thing about statically typed languages is\\nthat they help eliminate type conflicts at compile time rather than at runtime.\\nThis guarantee of safety ensures that programs are verified before they’re ever\\nexecuted. This feature is particularly helpful because it prevents very\\ncommon human errors that occur when developing a program: conflating an integer\\nand pointer, accessing an invalid piece of data, or buffer overflows, just to\\nname a few.</p>\\n<p>Performance is a rather large benefit we get from OCaml’s statically typed\\nsystem. Since any type conflicts are resolved at compile time, this eliminates\\nany need for type related safety checks at runtime. These kinds of checks are\\nnecessary for dynamically typed languages, which consequently add a slow\\noverhead, therefore slowing down the speed of the program itself. Most\\nscripting languages tend to be dynamically typed, so this simple change of\\ntype system puts OCaml far ahead of its peers with respect to speed. When it\\ncomes to benchmarking, OCaml is argued to be almost as fast as C, which is\\nincredibly impressive and unique considering it is a type safe language.</p>\\n<p>Not only is OCaml statically typed, but it also has type inference, which is\\nthe ability to automatically assume the data type of an expression at compile\\ntime, without its type needing to be explicitly defined. Rather, the compiler\\nwill generally either attempt to predict the type based on existing atomic data\\ntypes of the language, or it will try to gather information about the data\\nbeing analyzed, and come to a conclusion that way. As a matter of fact, entire\\nprograms can be written without explicitly declaring <em>any</em> types, and OCaml is\\nable to figure out all of the types automatically. Traditionally, this power\\ncomes at a cost; type inference is usually a relatively expensive feature to\\nsupport, and can be expected to ultimately slow down the compilation process.\\nIn OCaml, however, this isn’t the case due to its unique and revolutionary\\nimplementation of its type inference algorithm. OCaml has an interesting take\\non the usual approach; its own algorithm is a derivation of the common type\\ninference algorithm known as Algorithm W, only OCaml’s interpretation utilizes\\na graph based algorithm which ends up being a much more speed efficient\\nvariation of the traditional approach. The downside to the quick inference\\nimplementation, is that it can result in strange type errors in more\\ncomplicated programs.</p>\\n<h2>Modules and Functors</h2>\\n<p>Alongside these features, OCaml also comes with a mature module system that can\\nbe categorized into three key parts: signatures, structures, and functors. The\\nsignature of a module defines what type of data it can be parameterized with,\\nwhere the structure relates to how the body of the module is designed. Functors\\nare a very powerful feature in this module system; this is gives developers the\\nability to parameterize a module with <em>other</em> modules. This opens the door\\nto all sorts of complex programs; having modules that can be constructed using\\none or more other modules adds layers of abstraction that otherwise wouldn’t be\\nachievable in OCaml. A simple use case of functors could be the following:\\nlet’s say you have a module that creates a set of items, and in order to check\\nif an item already exists within a given set, we need to apply a custom\\nequality function. We can create an equality module and use it to parameterize\\nour set module so that we can apply our custom equality function within the set\\nmodule; this makes the set module a functor. Besides the support of functors,\\nthis module system can also be particularly helpful to developers for the\\nsimple added bonus of having namespacing within modules; this can help avoid\\nany naming conflicts that may occur in a program.</p>\\n<h2>Structure and Tool Set</h2>\\n<p>OCaml provides an extensive set of tools and libraries when it comes to\\ndevelopment, one of which being the interactive toplevel interpreter; this\\nsystem is designed in a read-eval-print loop where it repeatedly reads\\nexpressions from the input, type checks, compiles, evaluates, then prints the\\nresult. This is similar to how Racket’s interactive toplevel interpreter\\nworks (or Node.js, or most other interactive toplevel interpreters for that\\nmatter). Having this kind of tool makes the developer’s life very easy when\\nthey want to just test out some code quickly. The toplevel interpreter is also\\nused to interpret entire files of OCaml code; the general syntax is <code>ocaml options objects scriptfile</code>. Before a scriptfile is read by the interpreter,\\nOCaml will first search the current directory, and, if not found, then the\\n<code>HOME</code> directory for a <code>.ocamlinit</code> file. This file can be used to import\\nnecessary libraries that the program might need, or provide any other set up\\nrelated tasks.</p>\\n<p>OCaml also provides the developers with a bytecode compiler and a native code\\ncompiler. Similar to a C compiler, dependency ordering matters when trying to\\nlink and compile several files. This compiler will build and provide optimized\\nexecutable files that generally run faster than simply interpreting the source\\ncode, with the native code compiler usually being faster. The main purpose\\nof these compilers is for both portability and efficiency; OCaml is able to\\nbuild your files into very fast executables which, as we’ve mentioned earlier,\\nare roughly the same speed as C. There are some third party tools that\\nassist the developer in linking dependencies, one of the more popular ones\\nbeing <code>ocamake</code>; you feed it your source files and it will link them together\\nautomatically and the build them into an executable using the bytecode\\ncompiler. Tools like these alongside the compilers themselves really benefit\\nthe language in both efficiency and with being able to move code around on\\ndifferent systems.</p>\\n<p>Managing packages in OCaml is relatively easy due to the open source package\\nmanager called OPAM. This package manager supports multiple simultaneous\\ncompiler installations and also integrates well with a git based development\\nworkflows. OPAM is a way for engineers to easily install and share any open\\nsourced packages that they create and publish to the OPAM package registry,\\nwhich helps increase the speed of the development process by sharing commonly\\nused code. Especially for an emerging language like OCaml, the ability to\\nsimply distribute code and build a strong set of libraries really help the\\nlanguage grow and thrive as more developers begin to use it.</p>\\n<h2>In Closing</h2>\\n<p>OCaml is a powerful, general purpose functional programming language that has a\\nwide support for different needs. With its support of both imperative and\\nobject-oriented programming paradigms, it’s needless to say that this language\\nis very flexible when it comes to what the developer might need. With its\\nstatically typed system and very efficient implementation of its type inference\\nalgorithm, leveraging the native code compiler can result in OCaml programs\\nturning out to be almost as fast as C programs. With these strong\\ncharacteristics and features, it’s no wonder that OCaml is quickly growing in\\nthe open source software community; Facebook’s JavaScript static type checker,\\nFlow, is written in OCaml and proves to be one of the most revolutionary\\ntools a JavaScript developer can use. From using OCaml’s robust tool set and\\nspeedy execution, this software has quickly become one of the most popular\\nstatic type analyzers in the JavaScript community. All of OCaml’s features and\\nbenefits cause it to be an incredible language and tool to use in modern day\\napplications, and is slowly taking the world by storm as developers realize how\\npowerful it is.</p>\",\"frontmatter\":{\"date\":\"March 08, 2018\",\"path\":\"/blog/what-is-ocaml\",\"title\":\"What Is OCaml And Why Is It So Dope\",\"tags\":[\"language\"]}}},\"pathContext\":{}}\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./~/json-loader!./.cache/json/blog-what-is-ocaml.json\n// module id = 381\n// module chunks = 177863970890294"],"sourceRoot":""}